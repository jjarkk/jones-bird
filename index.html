<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jones Bird</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #333;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        #gameCanvas {
            border: 4px solid #555;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF); /* Sky background */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
    // --- SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Set canvas dimensions (standard flappy bird aspect ratio-ish)
    canvas.width = 320;
    canvas.height = 480;

    // Load the sprite image
    const heroSprite = new Image();
    heroSprite.src = 'image_0.png';

    // Game Variables
    let frames = 0;
    let score = 0;
    let highScore = localStorage.getItem('hipsterHighScore') || 0;
    let gameState = {
        current: 0,
        getReady: 0,
        game: 1,
        over: 2
    };

    // Sound effects (using simple web audio API oscillators for simplicity in a single file)
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
        if (gameState.current === gameState.over) return; // Don't play sounds on game over screen except crash
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        if (type === 'jump') {
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1);
        } else if (type === 'score') {
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.15);
        } else if (type === 'crash') {
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(100, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.3);
        }
    }


    // Control handler
    document.addEventListener('click', function() {
        switch(gameState.current) {
            case gameState.getReady:
                gameState.current = gameState.game;
                audioCtx.resume(); // Browser requirement to start audio
                playSound('jump');
                head.flap();
                break;
            case gameState.game:
                head.flap();
                playSound('jump');
                break;
            case gameState.over:
                resetGame();
                break;
        }
    });

    // --- GAME OBJECTS ---

    const head = {
        x: 50,
        y: 150,
        width: 34,
        height: 40, // slightly taller for topknot/beard
        radius: 16, // collision radius approximation based on image size
        gravity: 0.25,
        jump: 4.6,
        velocity: 0,
        rotation: 0,

        draw: function() {
            ctx.save();
            ctx.translate(this.x, this.y);
            // Rotate based on velocity
            if (this.velocity < 0) {
                 this.rotation = Math.max(-25 * Math.PI/180, this.rotation - 0.1);
            } else {
                 this.rotation = Math.min(70 * Math.PI/180, this.rotation + 0.05);
            }
            ctx.rotate(this.rotation);

            // Draw the sprite image centered
            // Assuming the image is roughly square, we use radius * 2 for width/height
            const size = this.radius * 2; 
            ctx.drawImage(heroSprite, -size / 2, -size / 2, size, size);

            ctx.restore();
        },

        update: function() {
            if (gameState.current !== gameState.game) return;

            this.velocity += this.gravity;
            this.y += this.velocity;

            // Floor collision
            if (this.y + this.radius >= canvas.height - fg.height) {
                this.y = canvas.height - fg.height - this.radius;
                if(gameState.current === gameState.game) {
                    playSound('crash');
                    gameState.current = gameState.over;
                }
            }
            // Ceiling collision
            if(this.y - this.radius <= 0) {
                this.y = this.radius;
                this.velocity = 0;
            }
        },

        flap: function() {
            this.velocity = - this.jump;
        },
        
        reset: function() {
             this.y = 150;
             this.velocity = 0;
             this.rotation = 0;
        }
    };

    // Foreground (Ground)
    const fg = {
        height: 100,
        x: 0,
        dx: 2,
        draw: function() {
            ctx.fillStyle = '#7ec850'; // Grass color
            ctx.fillRect(this.x, canvas.height - this.height, canvas.width, this.height);
            ctx.fillRect(this.x + canvas.width, canvas.height - this.height, canvas.width, this.height);
            
            // Add some texture to the ground
            ctx.fillStyle = '#69a842';
            ctx.beginPath();
            ctx.rect(this.x, canvas.height - this.height, canvas.width * 2, 10);
            ctx.fill();
        },
        update: function() {
            this.x = (this.x - this.dx) % (canvas.width);
        }
    };

    // Background (Simple clouds)
    const bg = {
        draw: function() {
             ctx.fillStyle = '#FFF';
             // Simple cloud shapes
             ctx.beginPath(); ctx.arc(80, 100, 20, 0, Math.PI * 2); ctx.fill();
             ctx.beginPath(); ctx.arc(110, 110, 25, 0, Math.PI * 2); ctx.fill();
             ctx.beginPath(); ctx.arc(140, 100, 20, 0, Math.PI * 2); ctx.fill();

             ctx.beginPath(); ctx.arc(250, 180, 20, 0, Math.PI * 2); ctx.fill();
             ctx.beginPath(); ctx.arc(280, 190, 25, 0, Math.PI * 2); ctx.fill();
        }
    };


    // Pipes (The Jeans)
    const jeans = {
        position: [],
        width: 60, // Width of the jeans pair
        gap: 120, // Gap between top and bottom jeans
        minHeight: 80, // Minimum height of a jeans segment
        dx: 2, // Speed of moving left

        draw: function() {
            for(let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                let topY = p.y;
                let bottomY = p.y + this.gap;
                
                // Draw Top Jeans (Hanging down)
                this.drawJeansPair(p.x, topY, true);
                
                // Draw Bottom Jeans (Standing up)
                this.drawJeansPair(p.x, bottomY, false);
            }
        },

        // Helper function to draw a pair of jeans
        drawJeansPair: function(x, y, isTop) {
            const denimColor = '#336699';
            const stitchColor = '#FFD700'; // Gold stitching
            const legWidth = this.width / 2 - 2;
            const height = isTop ? y : canvas.height - fg.height - y;
            const startY = isTop ? 0 : y;

            ctx.fillStyle = denimColor;

            // Draw left leg
            ctx.fillRect(x, startY, legWidth, height);
            // Draw right leg
            ctx.fillRect(x + legWidth + 4, startY, legWidth, height);

            // Draw waistband area connecting them
            const waistbandHeight = 20;
            let waistbandY = isTop ? height - waistbandHeight : y;
            ctx.fillRect(x, waistbandY, this.width, waistbandHeight);

            // Add stitching detail
            ctx.strokeStyle = stitchColor;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]); // Dashed lines for stitches
            
            ctx.beginPath();
            // Stitching along the legs
            ctx.moveTo(x + 5, startY); ctx.lineTo(x + 5, startY + height);
            ctx.moveTo(x + legWidth - 5, startY); ctx.lineTo(x + legWidth - 5, startY + height);
            ctx.moveTo(x + legWidth + 4 + 5, startY); ctx.lineTo(x + legWidth + 4 + 5, startY + height);
            ctx.moveTo(x + this.width - 5, startY); ctx.lineTo(x + this.width - 5, startY + height);
            
            // Stitching across waistband
            ctx.moveTo(x, waistbandY + 5); ctx.lineTo(x + this.width, waistbandY + 5);
            ctx.moveTo(x, waistbandY + waistbandHeight - 5); ctx.lineTo(x + this.width, waistbandY + waistbandHeight - 5);
            
            ctx.stroke();
            ctx.setLineDash([]); // Reset dashed lines
        },

        update: function() {
            if (gameState.current !== gameState.game) return;

            // Add new jeans periodically
            if (frames % 120 === 0) {
                const maxY = canvas.height - fg.height - this.gap - this.minHeight;
                // Random position for the gap
                const randomY = Math.floor(Math.random() * (maxY - this.minHeight + 1)) + this.minHeight;
                this.position.push({
                    x: canvas.width,
                    y: randomY
                });
            }

            for(let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                p.x -= this.dx;

                // Collision Detection (Simple AABB box approximation for the round head)
                let bottomPipeYPos = p.y + this.gap;
                
                // Hitbox for the head (slightly smaller than visual size for fairness)
                let headLeft = head.x - head.radius + 2;
                let headRight = head.x + head.radius - 2;
                let headTop = head.y - head.radius + 2;
                let headBottom = head.y + head.radius + 10; // Extended bottom for beard area

                // Check collision with Top Jeans OR Bottom Jeans
                // Top jeans collision
                if (headRight > p.x && headLeft < p.x + this.width && headTop < p.y) {
                     gameState.current = gameState.over;
                     playSound('crash');
                }
                // Bottom jeans collision
                if (headRight > p.x && headLeft < p.x + this.width && headBottom > bottomPipeYPos) {
                     gameState.current = gameState.over;
                     playSound('crash');
                }


                // Score update
                if (p.x + this.width < head.x - head.radius && !p.passed) {
                    score++;
                    playSound('score');
                    p.passed = true;
                    highScore = Math.max(score, highScore);
                    localStorage.setItem('hipsterHighScore', highScore);
                }

                // Remove off-screen jeans
                if(p.x + this.width <= 0) {
                    this.position.shift();
                    i--; // adjust iterator after removal
                }
            }
        },
        reset: function() {
             this.position = [];
        }
    };


    // --- GAME LOOP & UI ---

    function drawScore() {
        ctx.fillStyle = "#FFF";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.font = "50px Impact";

        if(gameState.current === gameState.game) {
            ctx.fillText(score, canvas.width/2 - 15, 80);
            ctx.strokeText(score, canvas.width/2 - 15, 80);
        } else if (gameState.current === gameState.over) {
            ctx.fillStyle = "white";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.font = "30px Impact";
            ctx.fillText("SCORE: " + score, 90, 200);
            ctx.strokeText("SCORE: " + score, 90, 200);
            
            ctx.fillText("BEST: " + highScore, 95, 240);
            ctx.strokeText("BEST: " + highScore, 95, 240);
        }
    }

    function drawMessage() {
        ctx.fillStyle = "#FFF";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.textAlign = "center";

        if (gameState.current === gameState.getReady) {
            ctx.font = "30px Impact";
            ctx.fillText("JONES BIRD", canvas.width / 2, 130);
            ctx.strokeText("JONES BIRD", canvas.width / 2, 130);
            ctx.font = "20px Courier New";
            ctx.fillText("Tap to Start", canvas.width / 2, 230);
            ctx.fillText("Avoid the blue jeans", canvas.width / 2, 260);
        } else if (gameState.current === gameState.over) {
            ctx.font = "40px Impact";
            ctx.fillText("GAME OVER", canvas.width / 2, 130);
            ctx.strokeText("GAME OVER", canvas.width / 2, 130);
            ctx.font = "20px Courier New";
            ctx.fillText("Tap to Restart", canvas.width / 2, 320);
        }
    }

    function resetGame() {
        head.reset();
        jeans.reset();
        score = 0;
        frames = 0;
        gameState.current = gameState.getReady;
    }


    function loop() {
        // Clear Canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Background Layer
        bg.draw();
        
        // Draw and Update Game Objects
        jeans.draw();
        jeans.update();
        
        fg.draw();
        fg.update();

        head.draw();
        head.update();

        // UI
        drawScore();
        drawMessage();

        frames++;
        requestAnimationFrame(loop);
    }

    // Start the game loop
    loop();

</script>
</body>
</html>
